<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Contour Lines over Perlin Noise</title>
  <style>
    body {
      margin: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: #2b2b2b;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    
    // Set canvas dimensions
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const width = canvas.width;
    const height = canvas.height;

    // Parameters
    const scale = 0.01; // Noise scale
    const contourLevels = 20; // Number of contour lines
    const lineColor = "white"; // Color of the contour lines

    // Perlin noise implementation
    function generatePerlinNoise(width, height, scale) {
      const gradP = [];

      function fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
      }

      function lerp(a, b, t) {
        return a + t * (b - a);
      }

      function grad(hash, x, y) {
        const h = hash & 3;
        const u = h < 2 ? x : y;
        const v = h < 2 ? y : x;
        return (h & 1 ? -u : u) + (h & 2 ? -v : v);
      }

      const perm = new Array(512);
      for (let i = 0; i < 256; i++) {
        perm[i] = i;
      }
      for (let i = 255; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [perm[i], perm[j]] = [perm[j], perm[i]];
      }
      for (let i = 0; i < 256; i++) {
        perm[256 + i] = perm[i];
      }

      for (let y = 0; y < height; y++) {
        gradP[y] = [];
        for (let x = 0; x < width; x++) {
          const xf = x * scale;
          const yf = y * scale;
          const X = Math.floor(xf) & 255;
          const Y = Math.floor(yf) & 255;

          const xRelative = xf - Math.floor(xf);
          const yRelative = yf - Math.floor(yf);

          const u = fade(xRelative);
          const v = fade(yRelative);

          const aa = perm[X + perm[Y]] % 12;
          const ab = perm[X + perm[Y + 1]] % 12;
          const ba = perm[X + 1 + perm[Y]] % 12;
          const bb = perm[X + 1 + perm[Y + 1]] % 12;

          const gAA = grad(aa, xRelative, yRelative);
          const gBA = grad(ba, xRelative - 1, yRelative);
          const gAB = grad(ab, xRelative, yRelative - 1);
          const gBB = grad(bb, xRelative - 1, yRelative - 1);

          const lerpX1 = lerp(gAA, gBA, u);
          const lerpX2 = lerp(gAB, gBB, u);
          gradP[y][x] = lerp(lerpX1, lerpX2, v);
        }
      }

      return gradP;
    }

    // Generate Perlin noise and draw contours
    function drawContourMap() {
      const noiseData = generatePerlinNoise(width, height, scale);

      // Calculate contour intervals
      const levels = [];
      for (let i = 0; i <= contourLevels; i++) {
        levels.push((i / contourLevels) * 2 - 1); // Map levels between -1 and 1
      }

      // Draw contours
      levels.forEach(level => {
        ctx.beginPath();
        for (let y = 0; y < height - 1; y++) {
          for (let x = 0; x < width - 1; x++) {
            const value = noiseData[y][x];
            if ((value >= level && noiseData[y][x + 1] < level) ||
                (value < level && noiseData[y][x + 1] >= level)) {
              const t = (level - value) / (noiseData[y][x + 1] - value);
              const px = x + t;
              ctx.moveTo(px, y);
              ctx.lineTo(px, y + 1);
            }

            if ((value >= level && noiseData[y + 1][x] < level) ||
                (value < level && noiseData[y + 1][x] >= level)) {
              const t = (level - value) / (noiseData[y + 1][x] - value);
              const py = y + t;
              ctx.moveTo(x, py);
              ctx.lineTo(x + 1, py);
            }
          }
        }
        ctx.strokeStyle = lineColor;
        ctx.stroke();
      });
    }

    drawContourMap();
  </script>
</body>
</html>
